<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>画板</title>
    <style type="text/css">
        .control {
            background-color: #f1efef;
            width: 150px;
            height: 600px;
            display: inline;
            float: left;
            border-right: #8c9493 2px solid;
        }

        .title {
            font-family: 'Weibei SC';
            color: #2c3e48;
            margin-left: 15%;
            font-size: 25px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .control_button {
            width: 80%;
            height: 35px;
            margin: 10px 10%;
            -moz-box-shadow: 0 10px 14px -7px #5e695f;
            -webkit-box-shadow: 0 10px 14px -7px #5e695f;
            box-shadow: 0 10px 14px -7px #5e695f;
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0.05, #a8adad), color-stop(1, #8c9493));
            background: -moz-linear-gradient(top, #a8adad 5%, #8c9493 100%);
            background: -webkit-linear-gradient(top, #a8adad 5%, #8c9493 100%);
            background: -o-linear-gradient(top, #a8adad 5%, #8c9493 100%);
            background: -ms-linear-gradient(top, #a8adad 5%, #8c9493 100%);
            background: linear-gradient(to bottom, #a8adad 5%, #8c9493 100%);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#a8adad', endColorstr='#8c9493', GradientType=0);
            background-color: #a8adad;
            -moz-border-radius: 6px;
            -webkit-border-radius: 6px;
            border-radius: 6px;
            display: inline-block;
            cursor: pointer;
            color: #ffffff;
            font-family: 'Hannotate SC';
            font-size: 9px;
            font-weight: bold;
            padding: 3px 32px;
            text-decoration: none;
            text-shadow: 0 1px 0 #141c13;
        }

        .control_button:hover {
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0.05, #8c9493), color-stop(1, #a8adad));
            background: -moz-linear-gradient(top, #8c9493 5%, #a8adad 100%);
            background: -webkit-linear-gradient(top, #8c9493 5%, #a8adad 100%);
            background: -o-linear-gradient(top, #8c9493 5%, #a8adad 100%);
            background: -ms-linear-gradient(top, #8c9493 5%, #a8adad 100%);
            background: linear-gradient(to bottom, #8c9493 5%, #a8adad 100%);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#8c9493', endColorstr='#a8adad', GradientType=0);
            background-color: #8c9493;
        }

        .control_button:active {
            position: relative;
            top: 1px;
        }

        #canvas {
            width: 1197px;
            height: 600px;
        }

        b {
            font-size: 20px;
        }
    </style>
</head>
<body>

<div style="width: 1350px; height: 600px; border: #8c9493 2px solid;">
    <div class="control">
        <div class="title">画布操作</div>
        <input type="button" value="画笔" id="draw" class="control_button"/>
        <input type="button" value="擦除" id="remove" class="control_button"/>
        <input type="button" value="清空" id="clear" class="control_button"/>
        <input type="button" value="识别" id="identify" class="control_button"/>
        <input type="button" value="导出" id="output" class="control_button"/>
        <input type="button" value="导入" id="input" class="control_button"/>
    </div>
    <div style="display: inline">
        <canvas height="600" width="1197" id="canvas" style="display: inline-grid;"></canvas>
    </div>

</div>

<script type="text/javascript">
    var canvas = document.querySelector("#canvas");
    var ctx = canvas.getContext("2d");

    //初始化当前画布为画笔状态
    canvas.isDraw = true;

    //按下事件
    canvas.addEventListener("mousedown", function (e) {
        //计算出鼠标点击在canvas中的位置
        var x = e.offsetX;
        var y = e.offsetY;

        //记录旧的点
        this.oldPoint = {
            x: x - 1,
            y: y - 1
        };

        if (this.isDraw) {
            //画笔功能
            draw(x, y);
        } else {
            //橡皮擦功能
            clearPart(x, y);
        }

        //绑定移动和抬起事件
        this.addEventListener("mousemove", move);
        this.addEventListener("mouseup", up);
    });

    function up() {
        this.removeEventListener("mousemove", move);
    }

    function move(e) {
        var x = e.offsetX;
        var y = e.offsetY;

        if (this.isDraw) {
            //画笔功能
            draw(x, y);
        } else {
            //橡皮擦功能
            clearPart(x, y);
        }

        this.oldPoint = {
            x: x,
            y: y
        }
    }

    // 画的方法
    function draw(x, y) {
        // console.log('x: ' + x);
        // console.log('y: '+ y);
        ctx.beginPath();

        // 线的宽度
        ctx.lineWidth = 3;

        // 线的样式
        ctx.lineCap = "round";
        ctx.moveTo(x, y);
        ctx.lineTo(canvas.oldPoint.x, canvas.oldPoint.y);
        ctx.stroke();
        ctx.closePath();
    }

    // 绘画按钮
    var drawBtn = document.getElementById('draw');
    drawBtn.onclick = function () {
        canvas.isDraw = true;
    };

    // 橡皮擦按钮
    var removeBtn = document.getElementById('remove');
    removeBtn.onclick = function () {
        // 改变状态为橡皮擦状态
        canvas.isDraw = false;
    };

    // 清空按钮
    var clearBtn = document.getElementById('clear');
    clearBtn.onclick = function () {
        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    // 识别按钮
    var identifyBtn = document.getElementById('identify');
    identifyBtn.onclick = function () {
        // TODO
    };

    // 导出按钮
    var outputBtn = document.getElementById('output');
    outputBtn.onclick = function () {
        // TODO
    };

    // 导入按钮
    var inputBtn = document.getElementById('input');
    inputBtn.onclick = function () {
        // TODO
    };

    //橡皮擦功能
    function clearPart(x, y) {
        //保存场景
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2, false);
        ctx.clip();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        //还原场景
        ctx.restore();
    }
</script>
</body>
</html>